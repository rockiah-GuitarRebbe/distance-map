<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Distance Viewer</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <!-- CSV & XLSX parsers -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body { margin:0; display:flex; height:100vh; font-family:Arial,sans-serif; overflow:hidden; }
    #sidebar { width:440px; background:#fafafa; border-right:1px solid #ddd; padding:14px; overflow-y:auto; }
    #map { flex:1; }

    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { cursor:pointer; }
    .meta { font-size:12px; color:#555; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ccc; border-radius:999px; font-size:12px; background:#fff; }

    .client { padding:8px; margin-bottom:8px; border:1px solid #ddd; border-radius:8px; background:#fff;
              display:flex; justify-content:space-between; gap:8px; }
    .client:hover { background:#f3f6ff; }
    .badge { padding:2px 8px; border-radius:999px; font-size:11px; color:#fff; text-transform:capitalize; }
    .badge.critical { background:#e53935; }
    .badge.high     { background:#fb8c00; }
    .badge.medium   { background:#fdd835; color:#222; }
    .badge.low      { background:#43a047; }

    .legend { display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:12px; margin-top:8px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .dot.critical{ background:#e53935; } .dot.high{ background:#fb8c00; }
    .dot.medium{ background:#fdd835; border:1px solid #aaa; } .dot.low{ background:#43a047; }
    progress { width:100%; }
    .toggle { display:flex; gap:8px; align-items:center; flex-wrap:wrap; font-size:12px; }
    .toggle label { display:flex; align-items:center; gap:4px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <!-- Therapist -->
    <div style="margin-bottom:16px; padding-bottom:10px; border-bottom:1px solid #ddd;">
      <b>Therapist Location</b>
      <div class="row" style="margin-top:6px;">
        <input id="therapistInput" type="text" placeholder="Enter ZIP or address" style="flex:1; padding:8px;" />
        <button id="setTherapistBtn">Set</button>
        <button id="clearTherapistBtn">Clear</button>
      </div>
      <div id="therapistNote" class="meta"></div>
    </div>

    <!-- Upload + Level -->
    <div style="margin-bottom:12px;">
      <b>Add Clients</b>
      <div class="row" style="margin-top:6px;">
        <input type="file" id="fileInput" accept=".csv,.txt,.xlsx" />
        <select id="levelSelect" title="Level for this file">
          <option value="critical">Critical</option>
          <option value="high">High</option>
          <option value="medium" selected>Medium</option>
          <option value="low">Low</option>
        </select>
        <button id="fitBtn" title="Fit map to all pins">Fit</button>
      </div>
      <label class="row" style="margin-top:6px;">
        <input type="checkbox" id="shareToggle" checked />
        <span>Share my additions</span>
      </label>
      <div class="legend">
        <span><span class="dot critical"></span> Critical</span>
        <span><span class="dot high"></span> High</span>
        <span><span class="dot medium"></span> Medium</span>
        <span><span class="dot low"></span> Low</span>
      </div>
      <div class="toggle" style="margin-top:6px;">
        <label><input type="checkbox" class="lvl-toggle" value="critical" checked/> Critical</label>
        <label><input type="checkbox" class="lvl-toggle" value="high" checked/> High</label>
        <label><input type="checkbox" class="lvl-toggle" value="medium" checked/> Medium</label>
        <label><input type="checkbox" class="lvl-toggle" value="low" checked/> Low</label>
      </div>
      <div id="importStatus" class="meta" style="margin-top:6px;"></div>
      <progress id="importProgress" value="0" max="100" style="display:none;"></progress>
    </div>

    <!-- Filters + Export -->
    <div class="row" style="margin:6px 0;">
      <input id="searchInput" type="text" placeholder="Search name or address" style="flex:1; padding:8px;" />
      <input id="radiusInput" type="number" min="0" step="1" placeholder="Radius (mi)" style="width:140px; padding:8px;" />
      <button id="exportBtn" title="Export visible to CSV">Export CSV</button>
    </div>

    <!-- Clients -->
    <div class="row" style="justify-content:space-between;">
      <div><b>Clients</b></div>
      <div id="counts" class="pill">0 shown / 0 total</div>
    </div>
    <div id="clientList"></div>

    <!-- Global clear -->
    <div class="row" style="margin-top:10px;">
      <button id="clearAllBtn" style="background:#fff3f3; border:1px solid #f1bcbc;">Clear All Clients (Global)</button>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // sockets (same-origin)
    const socket = io({ transports: ["websocket"] });

    // map
    const map = L.map("map").setView([39.5, -98.35], 4);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

    const layers = {
      critical: L.layerGroup().addTo(map),
      high:     L.layerGroup().addTo(map),
      medium:   L.layerGroup().addTo(map),
      low:      L.layerGroup().addTo(map),
    };
    const levelStyle = {
      critical: { color:"#e53935", fillColor:"#e53935" },
      high:     { color:"#fb8c00", fillColor:"#fb8c00" },
      medium:   { color:"#fdd835", fillColor:"#fdd835" },
      low:      { color:"#43a047", fillColor:"#43a047" },
    };

    let therapistMarker = null;
    let therapistLatLng = null;

    let clients = [];
    const clientKeys = new Set();      // name|address|level
    const markersByKey = new Map();    // key -> marker

    const therapistInput = document.getElementById("therapistInput");
    const therapistNote  = document.getElementById("therapistNote");
    const clientListDiv  = document.getElementById("clientList");
    const counts         = document.getElementById("counts");
    const fileInput      = document.getElementById("fileInput");
    const levelSelect    = document.getElementById("levelSelect");
    const importStatus   = document.getElementById("importStatus");
    const importProgress = document.getElementById("importProgress");
    const searchInput    = document.getElementById("searchInput");
    const radiusInput    = document.getElementById("radiusInput");

    const keyFor = (c) => `${(c.name||"").trim().toLowerCase()}|${(c.address||"").trim().toLowerCase()}|${c.level||"low"}`;

    function escapeHtml(str) {
      return String(str ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#039;");
    }

    function calcDist(a, b) {
      const R = 3958.8;
      const dLat = ((b.lat - a.lat) * Math.PI) / 180;
      const dLng = ((b.lng - a.lng) * Math.PI) / 180;
      const lat1 = (a.lat * Math.PI) / 180;
      const lat2 = (b.lat * Math.PI) / 180;
      const x = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return R * (2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x)));
    }

    async function geocode(addr, attempt=1) {
      const url = "https://nominatim.openstreetmap.org/search?format=json&countrycodes=us&limit=1&q=" + encodeURIComponent(addr);
      try {
        const r = await fetch(url, { headers: { "Accept-Language": "en" } });
        if (!r.ok) throw new Error("HTTP " + r.status);
        const data = await r.json();
        if (!Array.isArray(data) || data.length === 0) return null;
        return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
      } catch {
        if (attempt < 3) { await new Promise(res => setTimeout(res, 400*attempt)); return geocode(addr, attempt+1); }
        return null;
      }
    }

    function ensureMarker(c) {
      const k = keyFor(c);
      if (markersByKey.has(k)) return markersByKey.get(k);
      const style = levelStyle[c.level] || levelStyle.low;
      const marker = L.circleMarker([c.lat, c.lng], { radius:7, weight:2, opacity:1, fillOpacity:0.9, ...style })
        .bindPopup(`<b>${escapeHtml(c.name)}</b><br>${escapeHtml(c.address)}<br><span class="badge ${c.level}">${c.level}</span>`);
      (layers[c.level] || layers.low).addLayer(marker);
      markersByKey.set(k, marker);
      return marker;
    }

    function removeMarker(c) {
      const k = keyFor(c);
      const m = markersByKey.get(k);
      if (m) { m.remove(); markersByKey.delete(k); }
    }

    function fitToAllMarkers() {
      const pts = [];
      markersByKey.forEach(m => pts.push(m.getLatLng()));
      if (pts.length) map.fitBounds(L.latLngBounds(pts), { padding:[20,20] });
    }

    function addLocal(c) {
      const k = keyFor(c);
      if (clientKeys.has(k)) return false;
      clientKeys.add(k);
      clients.push(c);
      ensureMarker(c);
      return true;
    }

    function visibleClients() {
      const term = searchInput.value.trim().toLowerCase();
      const radStr = radiusInput.value.trim();
      const radius = radStr === "" ? null : Math.max(0, Number(radStr));
      const shownLevels = Array.from(document.querySelectorAll(".lvl-toggle"))
        .filter(cb => cb.checked).map(cb => cb.value);
      return clients.filter(c => {
        if (!shownLevels.includes(c.level)) return false;
        if (term) {
          const hay = `${c.name} ${c.address} ${c.level}`.toLowerCase();
          if (!hay.includes(term)) return false;
        }
        if (radius != null && therapistLatLng) {
          if (calcDist(therapistLatLng, c) > radius) return false;
        }
        return true;
      });
    }

    function renderList() {
      const list = therapistLatLng
        ? visibleClients().sort((a,b) => calcDist(therapistLatLng,a) - calcDist(therapistLatLng,b))
        : visibleClients();

      clientListDiv.innerHTML = "";
      counts.textContent = `${list.length} shown / ${clients.length} total`;

      for (const c of list) {
        const miles = therapistLatLng ? calcDist(therapistLatLng, c).toFixed(1) : "‚Äî";
        const row = document.createElement("div");
        row.className = "client";
        row.innerHTML = `
          <div>
            <div><b>${escapeHtml(c.name)}</b> <span class="badge ${c.level}">${c.level}</span></div>
            <div class="meta">${escapeHtml(c.address)}</div>
            <div class="meta"><b>${miles}</b> miles</div>
          </div>
          <div class="row">
            <select data-action="level">
              ${["critical","high","medium","low"].map(l => `<option value="${l}" ${l===c.level?'selected':''}>${l}</option>`).join('')}
            </select>
            <button data-action="fly">Pin</button>
            <button data-action="delete" title="Remove (global)">üóëÔ∏è</button>
          </div>
        `;
        row.querySelector('[data-action="fly"]').onclick = () => {
          const m = ensureMarker(c); map.setView(m.getLatLng(), 12); m.openPopup();
        };
        row.querySelector('[data-action="delete"]').onclick = () => socket.emit("removeWorker", c);
        row.querySelector('[data-action="level"]').onchange = (e) => {
          const newLevel = e.target.value;
          if (newLevel !== c.level) changeLevel(c, newLevel);
        };
        clientListDiv.appendChild(row);
      }
    }

    function changeLevel(oldClient, newLevel) {
      const oldKey = keyFor(oldClient);
      if (!clientKeys.has(oldKey)) return;
      removeMarker(oldClient);
      clientKeys.delete(oldKey);
      clients = clients.filter(x => keyFor(x) !== oldKey);

      const updated = { ...oldClient, level: newLevel };
      addLocal(updated);
      socket.emit("removeWorker", oldClient);
      socket.emit("addWorker", updated);
      renderList();
    }

    // socket events
    socket.on("currentWorkers", (list) => {
      clients = []; clientKeys.clear();
      markersByKey.forEach(m => m.remove()); markersByKey.clear();
      for (const c of list || []) addLocal({ ...c, level: c.level || "low" });
      renderList(); fitToAllMarkers();
    });

    socket.on("workerAdded", (c) => {
      if (addLocal({ ...c, level: c.level || "low" })) renderList();
    });

    socket.on("workersAddedBatch", (arr) => {
      let changed = false;
      for (const c of arr || []) changed = addLocal({ ...c, level: c.level || "low" }) || changed;
      if (changed) { renderList(); }
    });

    socket.on("workerRemoved", (c) => {
      const w = { ...c, level: c.level || "low" };
      const k = keyFor(w);
      if (clientKeys.has(k)) {
        clientKeys.delete(k);
        clients = clients.filter(x => keyFor(x) !== k);
        removeMarker(w);
        renderList();
      }
    });

    socket.on("allCleared", () => {
      clients = [];
      clientKeys.clear();
      markersByKey.forEach(m => m.remove());
      markersByKey.clear();
      renderList();
      map.setView([39.5, -98.35], 4);
    });

    // file upload (any Excel/CSV; auto-detect name/address)
    fileInput.addEventListener("change", async function () {
      const file = this.files?.[0];
      if (!file) return;
      const level = levelSelect.value;

      importStatus.textContent = "Parsing file‚Ä¶";
      importProgress.style.display = "block";
      importProgress.value = 0;

      let rows = [];
      try {
        rows = await readAnyTable(file); // -> [{name, address}]
      } catch {
        importStatus.textContent = "Could not read file.";
        importProgress.style.display = "none";
        return;
      }

      importStatus.textContent = `Geocoding ${rows.length} row(s)‚Ä¶`;
      const results = await geocodeInBatches(rows, 3, (done, total) => {
        importProgress.value = Math.floor((done / total) * 100);
      });

      const share = document.getElementById("shareToggle").checked;
      const toShare = [];
      let added = 0, failed = 0;

      for (const r of results) {
        if (!r.geo) { failed++; continue; }
        const worker = { name: r.name, address: r.address, lat: r.geo.lat, lng: r.geo.lng, level };
        if (addLocal(worker)) {
          added++;
          if (share) toShare.push(worker);
        }
      }

      if (toShare.length >= 10) {
        socket.emit("addWorkersBatch", toShare);
      } else if (toShare.length) {
        for (const w of toShare) socket.emit("addWorker", w);
      }

      renderList();
      fitToAllMarkers();
      importStatus.textContent = `Done. Added ${added}. Failed ${failed}.`;
      importProgress.style.display = "none";
      this.value = "";
    });

    // readAnyTable: detects name/address in CSV/XLSX with fuzzy headers and fallbacks
    async function readAnyTable(file) {
      const ext = (file.name.split(".").pop() || "").toLowerCase();
      if (ext === "xlsx") {
        const data = await file.arrayBuffer();
        const wb = XLSX.read(data, { type: "array" });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const matrix = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, blankrows: false });
        return extractNameAddressFromMatrix(matrix);
      } else {
        const matrix = await parseCsvToMatrix(file);
        return extractNameAddressFromMatrix(matrix);
      }
    }

    function parseCsvToMatrix(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: false,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data.map(row => row.map(cell => String(cell ?? "")))),
          error: (err) => reject(err),
        });
      });
    }

    function extractNameAddressFromMatrix(matrix) {
      const rows = matrix.filter(r => Array.isArray(r) && r.some(x => String(x).trim() !== ""));
      if (rows.length === 0) return [];

      // detect headers
      const headerRow = rows[0].map(x => String(x || "").trim());
      const looksLikeHeader = headerRow.some(h => /name|first|last|address|street|city|state|zip|postcode|location/i.test(h));
      const dataRows = looksLikeHeader ? rows.slice(1) : rows;

      const headers = looksLikeHeader
        ? headerRow.map(h => h.toLowerCase())
        : headerRow.map((_, i) => `col_${i}`);

      const idx = detectColumns(headers);

      const out = [];
      for (const r of dataRows) {
        let name = "";
        let address = "";

        if (idx.nameStrategy === "full") {
          name = String(r[idx.name] ?? "").trim();
        } else if (idx.nameStrategy === "first_last") {
          const first = String(r[idx.first] ?? "").trim();
          const last  = String(r[idx.last] ?? "").trim();
          name = [first, last].filter(Boolean).join(" ").trim();
        } else {
          const cells = r.map(x => String(x ?? "").trim()).filter(Boolean);
          name = cells[0] || "";
        }

        if (idx.addrStrategy === "full") {
          address = String(r[idx.address] ?? "").trim();
        } else if (idx.addrStrategy === "parts") {
          const parts = [];
          if (idx.street != null) parts.push(String(r[idx.street] ?? "").trim());
          if (idx.city   != null) parts.push(String(r[idx.city] ?? "").trim());
          if (idx.state  != null) parts.push(String(r[idx.state] ?? "").trim());
          if (idx.zip    != null) parts.push(String(r[idx.zip] ?? "").trim());
          address = parts.filter(Boolean).join(", ").replace(/\s+,/g, ",").trim();
        } else {
          const cells = r.map(x => String(x ?? "").trim()).filter(Boolean);
          address = cells[1] || "";
        }

        if (name && address) out.push({ name, address });
      }
      return out;
    }

    function detectColumns(headers) {
      const H = headers.map(h => h.toLowerCase().trim());

      // name candidates
      const nameIdx = findHeader(H, [/^name$/, /client/, /patient/, /full\s*name/]);
      const firstIdx = findHeader(H, [/^first$/, /^first[_\s]?name$/]);
      const lastIdx  = findHeader(H, [/^last$/, /^last[_\s]?name$/, /^surname$/]);

      // address candidates
      const addrIdx = findHeader(H, [/^address$/, /^address[_\s]?1$/, /full\s*address/, /^location$/]);
      const streetIdx = findHeader(H, [/^street$/, /^street[_\s]?1$/, /^address[_\s]?line[_\s]?1$/, /^addr1$/, /^road$/, /^line1$/]);
      const cityIdx   = findHeader(H, [/^city$/, /^town$/, /^locality$/]);
      const stateIdx  = findHeader(H, [/^state$/, /^province$/, /^region$/, /^state[_\s]?code$/]);
      const zipIdx    = findHeader(H, [/^zip$/, /^zipcode$/, /^postal$/, /^postcode$/, /^zip[_\s]?code$/]);

      const result = {
        nameStrategy: "fallback",
        addrStrategy: "fallback",
        name: null, first: null, last: null,
        address: null, street: null, city: null, state: null, zip: null
      };

      if (nameIdx != null) {
        result.nameStrategy = "full";
        result.name = nameIdx;
      } else if (firstIdx != null || lastIdx != null) {
        result.nameStrategy = "first_last";
        result.first = firstIdx ?? null;
        result.last  = lastIdx ?? null;
      }

      if (addrIdx != null) {
        result.addrStrategy = "full";
        result.address = addrIdx;
      } else if (streetIdx != null || cityIdx != null || stateIdx != null || zipIdx != null) {
        result.addrStrategy = "parts";
        result.street = streetIdx ?? null;
        result.city   = cityIdx ?? null;
        result.state  = stateIdx ?? null;
        result.zip    = zipIdx ?? null;
      }

      return result;
    }

    function findHeader(H, patterns) {
      for (let i = 0; i < H.length; i++) {
        const h = H[i];
        for (const p of patterns) {
          if (p.test(h)) return i;
        }
      }
      return null;
    }

    async function geocodeInBatches(rows, concurrency = 3, onProgress = () => {}) {
      let idx = 0, done = 0;
      const total = rows.length;
      const results = Array(total);
      const worker = async () => {
        while (true) {
          const i = idx++; if (i >= total) return;
          const r = rows[i];
          const geo = await geocode(r.address);
          results[i] = { ...r, geo };
          onProgress(++done, total);
        }
      };
      await Promise.all(Array.from({ length: Math.min(concurrency, total) }, worker));
      return results;
    }

    // filters / export
    document.querySelectorAll(".lvl-toggle").forEach(cb => cb.addEventListener("change", () => renderList()));
    searchInput.addEventListener("input", () => renderList());
    radiusInput.addEventListener("input", () => renderList());

    document.getElementById("exportBtn").onclick = () => {
      const rows = visibleClients().map(c => [c.name, c.address, c.level, c.lat, c.lng]);
      const csv = "name,address,level,lat,lng\n" + rows.map(r => r.map(safeCsv).join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "clients.csv"; a.click();
      URL.revokeObjectURL(url);
    };
    function safeCsv(v) {
      const s = String(v ?? "");
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    }

    // therapist
    document.getElementById("setTherapistBtn").onclick = async () => {
      const text = therapistInput.value.trim();
      if (!text) return;
      therapistNote.textContent = "Geocoding‚Ä¶";
      const geo = await geocode(text);
      if (!geo) { therapistNote.textContent = "Not found."; return; }
      therapistLatLng = geo;
      if (therapistMarker) map.removeLayer(therapistMarker);
      therapistMarker = L.marker([geo.lat, geo.lng], {
        icon: L.icon({ iconUrl: "https://cdn-icons-png.flaticon.com/512/684/684908.png", iconSize: [40, 40] })
      }).addTo(map);
      map.setView([geo.lat, geo.lng], 8);
      therapistNote.textContent = "";
      renderList();
    };

    document.getElementById("clearTherapistBtn").onclick = () => {
      therapistLatLng = null; therapistInput.value = ""; therapistNote.textContent = "";
      if (therapistMarker) map.removeLayer(therapistMarker); therapistMarker = null;
      renderList(); map.setView([39.5, -98.35], 4);
    };

    // clear all (global)
    document.getElementById("clearAllBtn").onclick = () => {
      if (confirm("Clear ALL clients for everyone?")) {
        socket.emit("clearAll");
      }
    };

    // fit to pins
    document.getElementById("fitBtn").onclick = () => fitToAllMarkers();
  </script>
</body>
</html>
